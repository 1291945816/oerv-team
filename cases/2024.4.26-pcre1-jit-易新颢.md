# 概览

- ### PCRE1 JIT 移植思路和大致结构流程

- ### gdb 辅助 JIT debug 
 
# 工作内容

- 本次工作主要是完成 pcre2 向 pcre1 的 RISC-V 的架构侧适配的 backport。

# 移植思路

- 根据了解 pcre1 是 pcre2 的历史版本，且在经过调研以后发现后者的 JIT 实现了 RISC-V 的架构适配，所以我们能够将 pcre2 jit 中的 RISC-V 部分进行迁移和修改，修改的时候也要对比两版api 的区别和作为 pcre 内部依赖的 jit_compile 函数中对一些 api 的改动来调整 jit_compile 中的一些引导编译流程，当然如果能够不修改 jit_compile 是最好的，毕竟还是要保证多架构在算法层面和汇编逻辑实现上的一致性。

# 大致结构及编译流程

- 由于 pcre jit 需要适配多个架构，且为了保证算法逻辑实现的一致性，jit 部分设计了一层专门的JIT 汇编抽象，其寄存器命名通常为 `SLJIT_RX` `SLJIT_SX` (其中 `x` 为数字) 的宏定义来命令，对应的汇编操作类型也使用了宏进行封装，其中 JIT 汇编中的寄存器会由每个架构不同的`reg_map` 来获取 JIT 汇编抽象的寄存器所对应的真实架构的寄存器，比如，在 RISC-V 架构下 `SLJIT_R0` 通过 `reg_map[SLJIT_R0]` 所映射到的真实寄存器为 `a0`。

- 在汇编代码生成上，jit_compile 的大致生成流程主要如下

	1. 预处理编译信息.
	2. 生成 compiler， 引导编译和存储编译中间产物.
	3. 写入 jit 函数入口到 compiler  buf.
	4. 根据 pattern 生成 match 算法流程并写入到 compiler buf (实际在根据不同的匹配操作会有递归或者不同的实现函数回落，需要具体追踪然后判断).
	5. 写入异常处理.
	6. 生成 code 到实际执行位置，同时根据 compiler 中的 jumps 和 labels 生成跳转
  
  根据这个流程，能够在进行样例debug的时候快速定位到一些问题 code 的出现位置和他们
   
# 问题定性和追踪

- 测试时难免会出现样例出错，不过都有的修，在样例有一定数量的情况下建议是对样本的错误类型进行分类以初步对问题进行定性，因为 jit 的问题通常不像一些有符号提供的程序一样能比较直观的指出出现问题的 code 出现在哪里，通常问题是在 compile code 阶段的时候才被引入，只有在运行阶段才会暴露，所以首先要对问题进行分批定性再进行追踪，这样做能减少很多追踪问题代码的无用工作量。
## gdb 的使用和代码追踪

- 说实话不是我确定本人的使用方法是否得当或者有更优解，本人目前的 debug 流程纯属自己摸索得出的产物，但是也足以应付一些小规模的纯汇编处理，当出现更大规模的

- JIT code 由于其特殊性质，如不做特殊处理，生成的代码只存在与内存当中，且因为不存在debug info ， 调试起来较为繁琐，本人在探索时首先是定位到了 JIT  函数被执行的地方，在跳转到结束后，通过 dump 一定长度的汇编并判断是否行成了跳转上的闭环来决定是否需要继续 dump， 直到 dump 出完整的 code 后，将其写入文本文件并保存，并根据一些具有特定规律的汇编代码 (比如函数入口(`sljit_emit_enter`)、函数返回值处理(`copy_ovector`)和函数返回(`sljit_emit_return`) 的汇编代码来对汇编代码进行块划分。

- 在完成初步分类之后开始一边对该部分代码进行调试，有时需要通过对内存地址进行断点(在gdb中使用[`break *<address>`](https://stackoverflow.com/questions/5459581/how-to-break-on-assembly-instruction-at-a-given-address-in-gdb))来捕获陷入异常时的各寄存器状态来判断为何陷入异常。

- 当对问题的发生有头绪以后，根据之前我们了解到的 compile 的大致流程我们应该很快就能够判断出问题代码在什么地方被生成，在对涉及本次修改的位置的实际实现进行排查看是否缺少了要素(我这里就需要追踪所有实际生成汇编和 labels 的位置进行跟踪排查)。
